import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* ================= BASIC SETUP ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222230);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 60, 100);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ================= LIGHTING ================= */
// Additional directional lights for full coverage
const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight2.position.set(-50, 100, -50);
scene.add(dirLight2);

const dirLight3 = new THREE.DirectionalLight(0xffffff, 0.4);
dirLight3.position.set(0, 100, 0);
scene.add(dirLight3);
/* ================= 3D ALUMINIUM BLOCK ================= */
const blockSize = 15;        // 40 cm x 40 cm
const blockThickness = 2;    // 2 cm thick

// Box for visual height
const blockMesh = new THREE.Mesh(
  new THREE.BoxGeometry(blockSize, blockThickness, blockSize),
  new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.35 })
);
scene.add(blockMesh);

// Plane on top for heat map
const planeGeometry = new THREE.PlaneGeometry(blockSize, blockSize, 80, 80);
const planeMaterial = new THREE.MeshStandardMaterial({
  vertexColors: true,
  side: THREE.DoubleSide,
  metalness: 0.7,
  roughness: 0.35
});
const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
planeMesh.rotation.x = -Math.PI / 2;
planeMesh.position.y = blockThickness / 2 + 0.01; // slightly above block
scene.add(planeMesh);

/* ================= INIT VERTEX COLORS ================= */
const colors = [];
for (let i = 0; i < planeGeometry.attributes.position.count; i++) {
  colors.push(0, 0, 1); // blue (cold)
}
planeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

/* ================= CONCENTRIC COILS ================= */
// Diameters: 5, 8, 11, 13 cm → radii: 2.5, 4, 5.5, 6.5
const coils = [
  { radius: 2.5, power: 200 },
  { radius: 4.0, power: 180 },
  { radius: 5.5, power: 150 },
  { radius: 6.5, power: 120 }
];

/* ================= DRAW COIL RINGS ================= */
function drawCoilRings() {
  coils.forEach(c => {
    const ringGeo = new THREE.RingGeometry(c.radius - 0.15, c.radius + 0.15, 128);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = blockThickness / 2 + 0.1; // above top
    scene.add(ring);
  });
}
drawCoilRings();

/* ================= HEAT MAP ================= */
function updateHeatMap() {
  const pos = planeGeometry.attributes.position;
  const col = planeGeometry.attributes.color;

  const spread = 2.8; // heat diffusion width (cm)

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const z = pos.getY(i); // plane rotated

    const r = Math.sqrt(x * x + z * z); // distance from center

    let heat = 0;

    coils.forEach(c => {
      const dr = r - c.radius;
      heat += c.power * Math.exp(-(dr * dr) / (spread * spread));
    });

    // Normalize heat 0–1
    const t = THREE.MathUtils.clamp(heat / 300, 0, 1);

    // Color gradient: blue → yellow → red
    const rCol = t;
    const gCol = 1.0 - Math.abs(t - 0.5) * 2.0;
    const bCol = 1.0 - t;

    col.setXYZ(i, rCol, gCol, bCol);
  }

  col.needsUpdate = true;
}

/* ================= SIMULATE DATA (REPLACE WITH ESP32) ================= */
function simulateESP32Data() {
  coils[0].power = 180 + Math.sin(Date.now() * 0.001) * 30;
  coils[1].power = 160 + Math.cos(Date.now() * 0.001) * 25;
  coils[2].power = 140;
  coils[3].power = 120;
}

/* ================= ANIMATION LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  simulateESP32Data(); // replace with real ESP32 data
  updateHeatMap();

  controls.update();
  renderer.render(scene, camera);
}

animate();

/* ================= HANDLE RESIZE ================= */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});